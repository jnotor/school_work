{"changed":true,"filter":false,"title":"DNDSim.1.cc","tooltip":"/personal/dnd_iteration2/DNDSim.1.cc","value":"//working as intended. time to clean up and add new features\n\n#include \"PlayerDND2.h\"\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <ctime>\n#include <unistd.h>\n\nusing namespace std;\n\nbool checkAC(int dRoll, int eAC)  {\n    if (dRoll >= eAC) return true;\n    return false;\n}\n\nint main()   {\n//////////////////////////////////////////////////////////////////////////////// Player Declaration - probably will want to make these easier to call/edit across implementations; maybe take the string of their name and make the default for that string their stats\n    \n    PlayerDND Blug(17,98,7,12,0,true,\"Blug\");\n    usleep(1000000);\n    PlayerDND Ajax(16,69,6,15,3,true,\"Ajax\");\n    usleep(1000000);\n    PlayerDND Elsby(18,73,7,15,2,true,\"Elsby\");                                              //going to be underpowered until spell save can be implemented\n    usleep(1000000);\n    PlayerDND Ragnar(15,75,6, 14,1,true,\"Ragnar\");                                            //calculating if two handed for dmg\n    usleep(1000000);\n    PlayerDND Baylin(15,53,6,15,1,true,\"Baylin\");\n    usleep(1000000);\n/////////////////////////////////////////Bad Guys\n    PlayerDND ABD(19,367,15,29,2,false,\"ABD\");       \n    usleep(1000000);\n    //PlayerDND kobold2(12,70,4,4,2,false,\"kobold2\");  \n    //usleep(1000000);                   \n    //playerdnd generic(AC, HP, tohit, avgdmg, int mod)\n//////////////////////////////////////////Total Combantant Storage\n\nvector <PlayerDND> Party = {Blug, Ajax, Elsby, Ragnar, Baylin};\nvector <PlayerDND> Enemies = {ABD};                                          //,kobold2\nvector <PlayerDND> eParticipants = Party;\neParticipants.insert(eParticipants.end(),Enemies.begin(),Enemies.end());\n\nPlayerDND hold;\n\n/////////////////////////////////////////////////////////////////////////////////roll for intiative\n\ncout << \"Int rolls are: \" << endl;\nfor (int i = 0; i < eParticipants.size(); ++i)   {                              \n     cout << eParticipants[i].getName() << \" rolled a \" << eParticipants[i].getInt() << endl;                      //rolls are not random right now...\n}\n//////////////////sorting for intiative                                         //is working\n\nfor (int j = 0; j < eParticipants.size(); ++j)   {\n    for (int i = 0; i < eParticipants.size()-1; ++i)   {\n        if (eParticipants[i].getInt() < eParticipants[i+1].getInt())   {\n            hold = eParticipants.at(i);\n            eParticipants.at(i) = eParticipants.at(i+1);\n            eParticipants.at(i+1) = hold;\n        }\n    }\n}\n\ncout << endl << \"combat order: \" << endl;\nfor (int i = 0; i < eParticipants.size(); ++i)   {\n    cout << eParticipants[i].getName() << endl;\n}\n\n////////////////////////////////////////////////////////////////////////////////Start combat\n\n///////////////////////////////////////////intializing health for both sides\nint partyHealth = 0;   \nint enemyHealth = 0;\n\nfor (int i = 0; i < Party.size(); ++i)   {\n    partyHealth += Party[i].getHP();\n}\n\nfor (int i = 0; i < Enemies.size(); ++i)   {\n    enemyHealth += Enemies[i].getHP();\n}\n\n//////////////////////////////////////////////starting combat\nint turn = 0;\nint combatRoll = 0;\nwhile ((partyHealth > 0) && (enemyHealth > 0)) {                                //keeps it going until 1 side loses\n    for (int j = 0; j < eParticipants.size();++j)   {\n        for (int i = 0; i < eParticipants.size(); ++i)   {                    //forgot number of attacks per turn\n            if (eParticipants[j].getParty() != eParticipants[i].getParty()) { //allows for fighting only between non allies\n                //attack\n                //break; only want to break out of the inner for loop tho...\n                if ((eParticipants[i].getHP()) > 0 && (eParticipants[j].getHP() > 0))   {\n                       combatRoll = eParticipants[j].d20Roll(); \n                       usleep(1000000);\n                    if (checkAC(combatRoll, eParticipants[i].getAC())==1) { //checkAC function is not working correctly\n                        cout << eParticipants[j].getName() << \" rolled a \" << combatRoll << \" and successfully attacks \" << eParticipants[i].getName()<< endl;\n                        eParticipants[i].loseHP(eParticipants[j].getAvgDmg());\n                        cout << eParticipants[i].getName() << \"'s health is now: \" << eParticipants[i].getHP() << endl << endl;\n                        if (eParticipants[i].getParty())   {\n                            partyHealth -= eParticipants[j].getAvgDmg();\n                        }\n                        else if (!eParticipants[i].getParty())   {\n                            enemyHealth -= eParticipants[j].getAvgDmg();\n                        }\n                    }\n                    else {\n                        cout << eParticipants[j].getName() << \" poop rolled a \" << combatRoll << endl;\n                        cout << \"Fail to attack!\" <<endl << endl;\n                    }\n                    break;\n                }\n            }\n        }\n    }\n    cout << \"party health is: \" <<partyHealth << endl;\n    cout << \"enemy party health is: \" << enemyHealth << endl;\n    ++turn;\n    cout << \"End of Round: \" << turn << endl;\n}\n\n//should probably cout individual health's after combat\n\n/*assumptions:\n   -whoever is attacking is always in range\n   -enemies are always intelligently, so that they avoid aoe damage\n   -no one ever makes a move that would cause an opportunity attack\n   -it is always a fight to one side's death\n*/\n    \n    \n    return 0;\n}\n\n","undoManager":{"mark":-2,"position":1,"stack":[[{"start":{"row":2,"column":19},"end":{"row":2,"column":20},"action":"remove","lines":["."],"id":2},{"start":{"row":2,"column":19},"end":{"row":2,"column":20},"action":"insert","lines":["2"]}],[{"start":{"row":2,"column":20},"end":{"row":2,"column":21},"action":"insert","lines":["."],"id":3}]]},"ace":{"folds":[],"scrolltop":0,"scrollleft":0,"selection":{"start":{"row":2,"column":21},"end":{"row":2,"column":21},"isBackwards":false},"options":{"guessTabSize":true,"useWrapMode":false,"wrapToView":true},"firstLineState":0},"timestamp":1524707995892}